---
layout: post
title: BOJ 12865번 평범한 배낭 - Knapsack 알고리즘 [C++]
comments: true
categories: [Algorithm]

# Insight
# Project
# Retrospect
# PS
# LogicDesign
# Contest
# DataStructure
# Java
# Algorithm

---

### 평범한 배낭

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

이 문제의 경우 무게 대비 가치를 따지는 **그리디** 문제로 보일 수 있으나, 조심!

> 분할 불가능한 배낭 문제
> 

이므로 dp 테이블을 채우며 최적해를 찾아나가야 한다.

그리디 알고리즘으로는 최적해를 구할 수 없다.

동적계획법을 위한 테이블은 **최대 무게**와 **주어지는 물건 개수** 두 개의 변수로 이루어진다.

예제 입력을 보자.

```
4 7
6 13
4 8
3 6
5 12
```

4개의 물건들이 주어지고 최대 합이 7보다 작도록 최대 가치의 물건을 담아야 한다.

dp 테이블을 채워보자

첫 번째 줄을 채워보자 `6 13`

| N  \ K | K = 1 | K = 2 | K = 3 | K = 4 | K = 5 | K = 6 | K = 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| N = 1 | 0 | 0 | 0 | 0 | 0 | 13 | 13 |
| N = 2 |  |  |  |  |  |  |  |
| N = 3 |  |  |  |  |  |  |  |
| N = 4 |  |  |  |  |  |  |  |

N = 1 일 때 첫 번째 물건의 무게가 6, 가치가 13이므로

**K가 물건의 가치보다 작을 때** 변하지 않고 크다면 `13` 임을 볼 수 있다.

두번째 줄을 채워보자 `4 8`

| N  \ K | K = 1 | K = 2 | K = 3 | K = 4 | K = 5 | K = 6 | K = 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| N = 1 | 0 | 0 | 0 | 0 | 0 | 13 | 13 |
| N = 2 | 0 | 0 | 0 | 8 | 8 | 13 | 13 |
| N = 3 |  |  |  |  |  |  |  |
| N = 4 |  |  |  |  |  |  |  |

이전 N=1, K=4일 때는 `0` 이였지만 

두 번째 물건의 무게 4를 담을 수 있어진 순간 (K == 4),  `0 → 8` 로 갱신할 수 있다.

하지만 다시 K=6일 때 8보다 13이 커서 갱신되지는 않는다.

세 번째 줄을 채워보자 `3 6`

| N  \ K | K = 1 | K = 2 | K = 3 | K = 4 | K = 5 | K = 6 | K = 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| N = 1 | 0 | 0 | 0 | 0 | 0 | 13 | 13 |
| N = 2 | 0 | 0 | 0 | 8 | 8 | 13 | 13 |
| N = 3 | 0 | 0 | 6 | 8 | 8 | 13 | 14 |
| N = 4 |  |  |  |  |  |  |  |

K=6 일때 까지는 이전까지 다르지 않다.

N=3이고 K=7의 칸을 채우는 경우를 살펴보자.

K는 두가지 경우의 수를 비교하여 선택할 수 있다.

1. N번째 물건을 포함하지 않을 것 인가?
2. N번째 물건을 포함할 것 인가?

`i` 번째 물건과 최대 무게 `j` 일때

- 1번째의 경우 최대무게가 `j` 이고 `i-1` 번째 물건을 담았을 때와 같다.
- 2번째의 경우 가치합은 
최대무게 `j - i번째 물건의 무게`일 때 `i-1` 개의 물건을 담는 경우와  `i번째 물건의 가치` 의 합과 같다

이를 일반화 시키면 

1. `dp[i][j]` = `dp[i-1][j]`
2. `dp[i][j]` = `dp[i-1][j - items[i].first] + items[i].second)`

### Bottom-Up

```cpp
int N, K;
int value[101],weight[101], dp[101][100001];

int main(){
    cin >> N >> K;
    for(int i=0;cin >> weight[i] >> value[i];i++);

    for(int i=1;i<=N;i++) for(int j=1;j<=K;j++)
        if(j < weight[i]) dp[i][j] = dp[i-1][j];
        else dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);
        
    cout << dp[N][K];
}
```

### Top-Down

```cpp
int ks(int n,int k){
    if(n < 0) return 0;
    if(dp[n][k]) return dp[n][k];
    if(k < weight[n]) return dp[n][k] = ks(n-1,k);

    return dp[n][k] = max(ks(n-1,k), ks(n-1,k-weight[n]) + value[n]) ;
}
```